---
# ----------------------------------------------------------------------------
# This work is licensed under a Creative Commons Attribution 4.0 International
# License. To view a copy of this license, visit:
#
# http://creativecommons.org/licenses/by/4.0/
# ----------------------------------------------------------------------------
Feature name: framework-config
Start date: 2016-08-11
Pull request: <leave empty>
Authors:
  - "@jakereps"
  - "@jairideout"
Contributors:
  - "<leave empty>"
  - "<leave empty>"
  - ...
---

# Summary

The QIIME 2 framework does not have a mechanism to allow users to configure its
behavior. This RFC proposes the addition of a configuration system and
a corresponding API to the framework.

# Glossary

*There is no new terminology introduced in this RFC*

# Motivation

The default behavior of the framework is often reasonable for many deployments,
but is not always sufficient. Furthermore, users may want to customize the
behavior of a system-wide install without having their changes affect other
users.

For example, some users may want to specify a different directory to hold
temporary files generated by the framework, as the default temporary directory
may not work on all deployments (e.g. an HPC cluster that does not have a
`/tmp/`). Another example is configuring computational resources, such as which
cluster queuing system to use for job submissions. As a final example, users can
configure whether they would like QIIME 2 to gather usage statistics, and report
back to the development team.

*These are only examples of possible configuration settings, and this RFC does
not attempt to define these, or other settings, but instead provides a generic
configuration system that will support arbitrary settings as needed.*

The expected outcome is an easily modifiable configuration system for end-users.

# Impact

The changes in this RFC will mostly affect end-users. They will be able to
easily, but also optionally, configure various settings defined by the
framework. For a majority of users the impact will be unnoticeable, as a default
configuration will be used. Users will only need to be aware of the
configuration system if they decide to change settings from their defaults.

The impact of this RFC currently won't affect plugin, or interface developers,
because the configuration system defined here only affects the QIIME 2
framework. Future RFCs could be proposed to support plugin, or interface
specific configuration.

# Detailed design

All proposed features of this RFC will live in a new module under the current
`qiime.sdk` API, and be accessible through an unambiguous module name, such as
`qiime.sdk.config`. The configuration system will be a module directory where
each specific category will be able to live in its own file to easily facilitate
future extensibility of the capabilities. Using the provided example of
configurable temporary directories, a file-structure would look something like
the following tree:

```bash
├── qiime
│   ├── sdk
│   │   ├── config
│   │   │   ├── __init__.py
│   │   │   ├── _config.py
│   │   │   ├── tempfile.py
│   │   │   └── ... other extensions here ...
│   │   ├── ...
│   │   │  
```

Where `tempfile.py` is essentially wrapping Python's built-in `tempfile`
package and supplying the configurable overrides by default.

***tempfile.py***
```python
import tempfile

from ._config import CONFIG # Import the configuration system

# Get any custom configuration, such as the filepath to a temporary directory
# otherwise return the default system tempfile.gettempdir()
def gettempdir():
    paths = CONFIG['Paths'] if 'Paths' in CONFIG else {}
    return paths.get('temp_dir', tempfile.gettempdir())

# Use your configurable path to override the built-in tempfile.mkdtemp(),
# which will be made accessible through qiime.sdk.config.mkdtemp()
def mkdtemp(suffix=None):
    return tempfile.mkdtemp(suffix, prefix='q2-', dir=gettempdir())
```

The majority of the work behind this will be the configuration system itself,
which will include creating and managing the configuration file(s) on the user's
machine, with the extensions able to simply connect to the configuration system
and get their necessary values. The backbone of the configuration system will be
on Python's built-in `configparser.ConfigParser()`, which will easily handle
reading the configuration files and storing the necessary data during the
framework's runtime.

Every configuration system needs a config file stored somewhere on the user's
filesystem to keep track of the settings long-term. This will be created upon
installation of QIIME 2, by (hopefully, as this is untested) hooking into
the installation process provided by `setuptools` and having it run a
pre-defined function to create the necessary directories and files on the users
machine. Failing the ability to hook into `setuptools` will require adding an
additional step to initialize the config directory.

There will be an order of precedence on configuration files, where server admins
may have a global configuration at `/etc/qiime2/` that supplies cluster or
system specific rules. The QIIME 2 configuration will be set using the following
precedence: Environment Variables will override local `click.get_app_dir()`
configurations, which will override global `/etc/qiime2` configuration settings.

A configuration directory's location should use the generally agreed upon method
of storing the data in the user's Application support directory. In order to
not have to worry about manually figuring this location out based on user OS,
the configuration system will use the `get_app_dir` method provided by the
third-party Click package (which being a requirement of `q2cli` adds no
unnecessary dependency requirements). This will return the necessary path to
build the QIIME 2 directory, and any nested directories and files that are
required by the configuration system. In addition to this, an API will be
provided to allow the user to know exactly where this configuration data is
located on their machine.

The addition of nested directories within the configuration folder will allow
the configurations to be grouped by the framework version numbers, allowing the
configuration system, should it drastically change on a version bump, to be able
to potentially attempt a migration of the older version's configuration. Having
this logic within the configuration system will allow the framework to actually
rewrite the configuration file, should a user accidentally misspell something,
or provide invalid input. If this were to occur the framework would display a
warning saying that the user's configuration was invalid and has been rewritten
using their correctly provided values, and any invalid settings to be set to the
defaults.

The configuration directory would look similar to the following:

```bash
├── QIIME 2
│   ├── 2.0.x
│   │   └── config.ini
│   ├── 2.0.y
│   │   └── config.ini
```

A barebones example of the configuration system, using the mentioned techniques,
would go as follows:

***_config.py***
```python
import click
import configparser
import os

CONFIG_DIR = click.get_app_dir('QIIME 2', roaming=False, force_posix=False)
VERSION_DIR = os.path.join(CONFIG_DIR, '2.0.x')
CONFIG_FILE = os.path.join(VERSION_DIR, 'config.ini')

CONFIG = configparser.ConfigParser()
CONFIG.read(CONFIG_FILE)
```

Finally if a user would like to undo their changes, or just go back to a
completely stock install of the QIIME 2 package, without actually having to
reinstall, an API will be provided to wipe and reset the configuration directory
to all of the defaults that were shipped with QIIME 2. Assuming default
configurations are provided through the actual files themselves, and not coded
into QIIME 2, that would look something like the following (where
`'../boilerplate'` would be a directory within the codebase pre-populated with
the default settings directory):

***_util.py***
```python
import os
import shutil

from ._config import VERSION_DIR

BOILERPLATE_DIR = os.path.join(os.path.dirname(__file__), 'boilerplate')


def reset_config():
    try:
        shutil.rmtree(VERSION_DIR)
    except FileNotFoundError:
        pass
    shutil.copytree(BOILERPLATE_DIR, VERSION_DIR)
```

# How We Teach This

This RFC introduces an idea that is wholly new to the QIIME 2 framework, and
because of this it allows this system to be easily introduced. A vast majority
of computer users are familiar with configuration files of some sort, be it
actually modifying a dotfile, or changing their configurations through drop-down
menus via a GUI. The simpleness of a `.ini` file layout, and having the API
available to let a user know exactly where that file lives on their machine will
make this possibly one of the simplest features to introduce.

Teaching the fact that this feature exists can be incorporated into any
documentation for a feature that is configurable through this system. An example
using the temporary directory configuration could be on the documentation for
one of the `Result` objects, be it an `Artifact` or `Visualization`, where it is
just mentioned that while being worked with, the data files are stored in a
temporary directory that is configurable through our `config.ini` file, located
at: /path/to/config/file.

# Drawbacks

Seeing as this will ship with default values, and only change if a user wants
it to, there are no known drawbacks to any of the features proposed in this RFC.

# Alternatives

An alternative to this would to be provide APIs to manipulate the default
settings by the user, but is not nearly as friendly as a full-feature
configuration system. Not doing this could potentially cause the framework to
not work properly without manual code modification by a user.

# Unresolved questions

- Do the default settings live in an included directory, or are they hard-coded
  into the framework's configuration logic?
- Is fully rewriting any defaults that a user deletes instead of handling it
  with internal logic an expected behavior of a configuration system?
